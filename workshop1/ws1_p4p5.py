# -*- coding: utf-8 -*-
"""WS1_P4P5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VMutQXIZhzUjM8A5iZc1Sd6i3ptkHG-o
"""

# Commented out IPython magic to ensure Python compatibility.
# %pylab inline

"""# Building a Robot Simulator in 2D

### Euler integration
"""

# Perfect sensor
def sense(x):
    return x

def simulate(Δt, x, u):
    x += Δt * u
    return x

"""### Control policy"""

def control(t, p, err_dt, two):
    ### WRITE YOUR CONTROL POLICY HERE:

    ### Problem 4
    if t > 0 and t <= 1:
      ux = 15
      uy = 0
    elif t > 1 and t <= 2:
      ux = 0
      uy = 4.5
    elif t > 2 and t <= 3:
      ux = -10
      uy = 0
    elif t > 3 and t <= 4:
      ux = 0
      uy = 9.5
    elif t > 4 and t <= 5:
      ux = 3
      uy = 0
    elif t > 5 and t <= 6:
      ux = 0
      uy = -7
    elif t > 6 and t <= 7:
      ux = -3
      uy = 0
    elif t > 7 and t <= 8:
      ux = 0
      uy = 10
    elif t > 8 and t <= 9:
      ux = 9
      uy = 0
    else:
      ux = 0
      uy = 0

    ### Problem 5
#    if t > 0 and t <= 1:
#      x2 = 0
#      x3 = 2.5625
#      x4 = -.40625
#      y2 = 0
#      y3 = -.25
#      y4 = .0625
#    elif t > 1 and t <= 2:
#      x2 = 1
#      x3 = -.75
#      x4 = .125
#      y2 = 1
#      y3 = .09375
#      y4 = -.015625
#    elif t > 3 and t <= 4:
#      x2 = 1
#      x3 = -2.625
#      x4 = .4375
#      y2 = 1
#      y3 = -.75
#      y4 = .125
#    elif t > 4 and t <= 5:
#      x2 = 2
#      x3 = -6
#      x4 = 4
#      y2 = 2
#      y3 = 22.5
#      y4 = -15
#    elif t > 5 and t <= 6:
#      x2 = 2
#      x3 = -1
#      x4 = .11
#      y2 = 2
#      y3 = -1.58
#      y4 = .175
#    elif t > 6 and t <= 7:
#      x2 = 2
#      x3 = -1.04
#      x4 = .09
#      y2 = 2
#      y3 = -.85
#      y4 = .081
#    elif t > 7 and t <= 8:
#      x2 = 2
#      x3 = -.75
#      x4 = .0625
#      y2 = 2
#      y3 = -.28
#      y4 = .02
#    elif t > 8 and t <= 9:
#      x2 = 2
#      x3 = -.11
#      x4 = 0
#      y2 = 2
#      y3 = -.444
#      y4 = .025
#    else:
#      x2 = 0
#      x3 = 0
#      x4 = 0
#      y2 = 0
#      y3 = 0
#      y4 = 0
      
#    ux = x2 + (2*x3*t) + (3*x4*(t**2))
#    uy = y2 + (2*y3*t) + (3*y4*(t**2))
    return array([ux, uy])

"""### Running the simulator"""

import numpy as np
tf = 8
Δt = 0.05    # Time step
time = linspace(0.,tf, int(tf / Δt) + 1)  # Time interval


# Initial conditions


x = array([-5, -7.])
x_log = [copy(x)]
err_dt = [0.,0.]
# robot 2
#x2 = array([2., 0.])
#x2_log = [copy(x)]

for t in time:
    p = sense(x)
    u = control(t, p, err_dt, False)    
    x = simulate(Δt, x, u)


    x_log.append(copy(x))
    
x_log = array(x_log)

grid()
plot(x_log[:,0], x_log[:,1])
# robot 2
#plot(x2_log[:,0], x2_log[:,1])

import matplotlib.pyplot as plt
from matplotlib import animation
!pip install JSAnimation
from JSAnimation import IPython_display    
from IPython.display import HTML
    


fig, ax = plt.subplots()

def animate(t):
    ax.clear()
    
    # Path
    plot(x_log[:,0], x_log[:,1], 'r--')
    
    # Initial conditions
    plot(x_log[t,0], x_log[t,1], 'bo')
    
    

anim = animation.FuncAnimation(fig, animate, frames=len(time), interval=60)

HTML(anim.to_jshtml())